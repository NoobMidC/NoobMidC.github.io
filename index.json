[{"categories":[],"content":"Golang 八股文 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:0:0","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"基础数据结构 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:0","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"1. go的指针和c的指针 ​ 相同点: ​ 运算符相同, \u0026为取地址, *为解引用 ​ 不同点: 数组名和数组首地址. c语言中arr、\u0026arr[0]为数组的首个元素地址,单位偏移量为元素大小; \u0026arr为数组的首地址,单位偏移量为数组大小. golang中\u0026arr[0]和\u0026arr与c语言中相同, 但是arr表示为整个数组的值. // C int arr[5] = {1, 2, 3, 4, 5}; // Go // 需要指定长度，否则类型为切片 arr := [5]int{1, 2, 3, 4, 5} 指针运算. c语言中指针本质为无符号整数,代表内存地址, 可以进行加减运算. Golang中指针为 *uint32类型非数字,不可以加减运算. Go 标准库中提供了一个 unsafe 包用于编译阶段绕过 Go 语言的类型系统，直接操作内存 uintptr : Go 的内置类型。是一个无符号整数，用来存储地址，支持数学运算。常与 unsafe.Pointer 配合做指针运算 unsafe.Pointer : 表示指向任意类型的指针，可以和任何类型的指针互相转换（类似 C 语言中的 void* 类型的指针），也可以和 uintptr 互相转换 unsafe.Sizeof : 返回操作数在内存中的字节大小，参数可以是任意类型的表达式，例如 fmt.Println(unsafe.Sizeof(uint32(0)))的结果为 4 unsafe.Offsetof : 函数的参数必须是一个字段 x.f，然后返回 f 字段相对于 x 起始地址的偏移量，用于计算结构体成员的偏移量 golang中不能被寻址的类型:(不可变的，临时结果和不安全的。) 常量、字符串、函数或方法、map中的元素… ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:1","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"2. String的底层结构 type StringHeader struct { // 16 字节 Data uintptr Len int } 本质为byte类型的数组 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:2","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"3.slice和array的区别和底层结构 ​ array 为定长数组, slice为不定长数组 底层结构 type slice struct { array unsafe.Pointer // array指针指向底层array的某一个元素，其决定slice所能控制的内存片段的起始位置，这里需要注意的是，array不一定指向底层array的首元素，这与slice的创建有关。 len int //len 代表当前切片的长度,限定slice可直接通过索引(下标)存取元素的范围 cap int // cap 是当前切片的容量,表示slice所引用的array片段的真实大小 } // slice 扩张: slice扩容规则是：在1024字节以内，扩容一倍，大于1024时，增加cap的1/4 初始化方式: // 数组 // 切片 a := [3]int{1,2,3} //指定长度 s := make([]int, 3) //指定长度 a := [...]int{1,2,3} //不指定长度 s := []int{1,2,3} //不指定长度 函数传递 当切片和数组作为参数在函数（func）中传递时，数组传递的是值，而切片传递的是指针。因此当传入的切片在函数中被改变时，函数外的切片也会同时改变。相同的情况，函数外的数组则不会发生任何变化。 nil切片和空切片最大的区别在于指向的数组引用地址是不一样的 所有的空切片指向的数组引用地址都是一样的 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:3","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"4. Map底层结构 用于存储一系列无序的键值对,hashmap作为底层实现 基本数据结构: // hashmap的简称 type hmap struct { count int //元素个数 flags uint8 //标记位 B uint8 //buckets的对数, 说明包含2^B个bucket noverflow uint16 //溢出的bucket的个数 hash0 uint32 //hash种子 buckets unsafe.Pointer //指向buckets数组的指针，数组个数为2^B oldbuckets unsafe.Pointer //扩容时使用，buckets长度是oldbuckets的两倍 nevacuate uintptr //扩容进度，小于此地址的buckets已经迁移完成 extra *mapextra //扩展信息 } //当map的key和value都不是指针，并且size都小于128字节的情况下，会把 bmap 标记为不含指针，这样可以避免gc时扫描整个hmap。但是，我们看bmap其实有一个overflow的字段，是指针类型的，破坏了bmap不含指针的设想，这时会把overflow移动到extra字段来。 type mapextra struct { overflow *[]*bmap oldoverflow *[]*bmap //用于扩容 nextOverflow *bmapx //prealloc的地址 } // bucket type bmap struct { tophash [bucketCnt]uint8 //bucketCnt = 8,用于记录8个key哈希值的高8位，这样在寻找对应key的时候可以更快，不必每次都对key做全等判断 // keys [8]keytype // values [8]valuetype // pad uintptr // overflow uintptr } ​ hmap结构图 如何扩容 ​ 触发条件: 1. 装填因子大于6.5(装填因子为2^B); 2. overflow bucket 太多 ​ 解决办法: 双倍扩容:扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁2 个 bucket.(条件1) 等量扩容:重新排列，极端情况下，重新排列也解决不了，map成了链表，性能大大降低，此时哈希种子 hash0 的设置，可以降低此类极端场景的发生。(条件2) 赋值操作 在查找key之前，会做异常检测，校验map是否未初始化，或正在并发写操作，如果存在，则抛出异常：（这就是为什么map 并发写回panic的原因） 需要计算key 对应的hash 值，如果buckets 为空（初始化的时候小于一定长度的map 不会初始化数据）还需要初始化一个bucket 通过hash 值，获取对应的bucket。如果map 还在迁移数据，还需要在oldbuckets中找对应的bucket，并搬迁到新的bucket。 拿到bucket之后，还需要按照链表方式一个一个查，找到对应的key， 可能是已经存在的key，也可能需要新增。 插入数据前，会先检查数据太多了，需要扩容，如果需要扩容，那就从第③开始拿到新的bucket，并查找对应的位置。 如果没有空的位置，那就需要在链表后追加一个bucket，拿到kv 最后更新tophash 和 key 的字面值, 并解除hashWriting 约束 数据迁移 先要判断当前bucket是不是已经转移。 (oldbucket 标识需要搬迁的bucket 对应的位置) 如果没有被转移，那就要迁移数据了。数据迁移时，可能是迁移到大小相同的buckets上，也可能迁移到2倍大的buckets上。这里xy 都是标记目标迁移位置的标记：x 标识的是迁移到相同的位置，y 标识的是迁移到2倍大的位置上。 确定bucket位置后，需要按照kv 一条一条做迁移。（目的就是清除空闲的kv） 数据查找 ​ Go语言中 map采用的是哈希查找表，由一个 key 通过哈希函数得到哈希值，64 位系统中就生成一个64bit 的哈希值，由这个哈希值将 key 对应到不同的桶bucket中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突。key 经过 hash 后共64 位，根 据 hmap中 B的值，计算它到底要落在哪个桶时，桶的数量为2^B，如 B=5，那么用64 位最后5 位表示第几号桶，在用 hash 值的高8 位确定在 bucket 中的存储位置，当前 bmap中的 bucket 未找到，则查询对应的 overflow bucket，对应位置有数据则对比完整的哈希值，确定是否是要查找的数据。如果两个不同的 key 落在的同一个桶上，hash 冲突使用链表法接近，遍历 bucket 中的 key ;如果当前处于 map进 行了扩容，处于数据搬移状态，则优先从 oldbuckets 查找。 根据key计算出hash值。 如果存在old table, 首先在old table中查找，如果找到的bucket已经evacuated，转到步骤3。 反之，返回其对应的value。 在new table中查找对应的value。 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:4","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"5. Channel 底层结构 type hchan struct { qcount uint // 队列中的数据个数 dataqsiz uint // 环形队列的大小，channel本身是一个环形队列 buf unsafe.Pointer // 存放实际数据的指针，用unsafe.Pointer存放地址，为了避免gc elemsize uint16 closed uint32 // 标识channel是否关闭 elemtype *_type // 数据 元素类型 sendx uint // send的 index recvx uint // recv 的 index recvq waitq // 阻塞在 recv 的队列 sendq waitq // 阻塞在 send 的队列 lock mutex // 锁 } channel本身是一个环形缓冲区，数据存放到堆上面，channel的同步是通过锁实现的，并不是想象中的lock-free的方式，channel中有两个队列，一个是发送阻塞队列，一个是接收阻塞队列。当向一个已满的channel发送数据会被阻塞，此时发送协程会被添加到sendq中，同理，当向一个空的channel接收数据时，接收协程也会被阻塞，被置入recvq中。 ​ 创建channel 缓冲区大小为0: 只需要分配hchansize大小的内存就ok; 缓冲区大小不为0，且channel的类型不包含指针: buf为hchanSize+元素大小*元素个数的连续内存 缓冲区大小不为0，且channel的类型包含指针，则不能简单的根据元素的大小去申请内存，需要通过mallocgc去分配内存(即内存逃逸) channel特性 1. 给一个 nil channel 发送数据，造成永远阻塞 2. 从一个 nil channel 接收数据，造成永远阻塞 3. 关闭一个 nil channel 将会发生 panic 4. 给一个已经关闭的 channel 发送数据，引起 panic 当 c.closed != 0 则为通道关闭，此时执行写，源码提示直接 panic，输出的内容就是上面提到的 \"send on closed channel\"。 1. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 c.closed != 0 \u0026\u0026 c.qcount == 0 指通道已经关闭，且缓存为空的情况下（已经读完了之前写到通道里的值） 如果接收值的地址 ep 不为空 那接收值将获得是一个该类型的零值 typedmemclr 会根据类型清理相应地址的内存 这就解释了上面代码为什么关闭的 chan 会返回对应类型的零值 1. 无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:5","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"6. interface // interface 分为空接口和非空接口，分别用eface 和 iface实现。 // eface type eface struct { _type *_type data unsafe.Pointer //指向数据的数据指针 } //_type 定义 type _type struct { size uintptr // 类型的大小 ptrdata uintptr // size of memory prefix holding all pointers hash uint32 // 类型的Hash值 tflag tflag // 类型的Tags align uint8 // 结构体内对齐 fieldalign uint8 // 结构体作为field时的对齐 kind uint8 // 类型编号 定义于runtime/typekind.go alg *typeAlg // 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值 gcdata *byte // GC相关信息 str nameOff // 类型名字的偏移 ptrToThis typeOff } // iface type iface struct { tab *itab data unsafe.Pointer } // 非空接口的类型信息 type itab struct { inter *interfacetype // 接口定义的类型信息 _type *_type // 接口实际指向值的类型信息 link *itab bad int32 inhash int32 fun [1]uintptr // 接口方法实现列表，即函数地址列表，按字典序排序 } // 非空接口类型，接口定义，包路径等。 type interfacetype struct { typ _type pkgpath name mhdr []imethod // 接口方法声明列表，按字典序排序 } // 接口的方法声明 type imethod struct { name nameOff // 方法名 ityp typeOff // 描述方法参数返回值等细节 } 非空interface与eface不同的，所有空interface的结构是一样的，而非空interface每个都不一样，因为彼此定义的方法可以不一样的，所以相对eface，iface的定义复杂多。 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:6","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"7. reflect t := reflect.TypeOf(stru).Elem() for i := 0; i \u003c t.NumField(); i++ { // 获取Tag t.Field(i).Name, t.Field(i).Tag.Get(\"json\"), t.Field(i).Tag.Get(\"otherTag\") } //reflect.TypeOf(stru).Elem()获取指针指向的值对应的结构体内容。 //NumField()可以获得该结构体的含有几个字段。 //遍历结构体内的字段，通过t.Field(i).Tag.Get(\"json\")可以获取到tag为json的字段。 json包里不能导出私有变量的tag是因为json包里认为私有变量为不可导出的Unexported，所以跳过获取名为json的tag的内容 //1. 类型识别 var data interface{} = \"hello\" strValue, ok := data.(string) if ok { fmt.Printf(\"%s is string type\\n\", strValue) } //2. 类型获取 var str string = \"hello\" fmt.Println(reflect.TypeOf(str)) //3. 类型判断 func typeJudge(x interface{}) { switch x.(type){ case int,int8,int64,int16,int32,uint,uint8,uint16,uint32,uint64: fmt.Println(\"整型变量\") case float32,float64: fmt.Println(\"浮点型变量\") case []byte,[]rune,string: fmt.Println(\"字符串变量\") default: fmt.Println(\"不清楚...\") } } ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:7","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"8. new 和make的区别 new(T) 返回的是 T 的指针：new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零值。 make 只能用于 slice,map,channel，返回值是经过初始化之后的 T 的引用 make 分配空间后，会进行初始化 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:8","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"9.struct能不能比较 ​ go中的struct能不能比较取决于struct内部存储的数据，如果struct中的字段都是可比较的，那么该struct就是可比较的，如果其中的字段是不可比较的，那么该struct不可比较。slice,map就无法比较。 struct字段顺序要一致才能比较 数组的长度是类型的一部分，如果数组长度不同，无法比较。 interface{}类型的比较包含该接口变量存储的值和值的类型两部分组成，分别称为接口的动态类型和动态值。只有动态类型和动态值都相同时，两个接口变量才相同。 slice在go设计之初为了和数组区分，不让其可以比较（浅层指针比较没有意义） 1、引用类型，比较地址没有意义。 2、切片有len，cap，比较的维度不好衡量，因此go设计的时候就不允许切片可比较。 3、map的value, 函数均可以包含slice,因而均不可比较 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:9","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"10. defer defer关键字定义的函数是在调用函数返回之后执行，而不是在代码块退出之后执行。defer的执行顺序是先创建的后执行。看做是一个 FILO(First In Last Out) 栈. 所有传入defer函数的参数都是在创建的时候立即计算处理的，而不是调用函数退出的时候计算的 defer等到包含它的程序返回时(包含它的函数执行了return语句、运行到函数结尾自动返回、对应的goroutine panic）defer函数才会被执行。通常用于资源释放、打印日志、异常捕获等 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:10","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"11. init函数 整个golang程序初始化顺序 先调用osinit，再调用schedinit，创建就绪队列并新建一个G，接着就是mstart 即设置好本地线程存储，设置好main函数参数，根据环境变量GOMAXPROCS设置好使用的procs，初始化调度器和内存管理等等。 main.main之前的准备 sysmon :Go语言的runtime库会初始化一些后台任务，其中一个任务就是sysmon. 它由物理线程运行.主要处理两个事件：对于网络的epoll以及抢占式调度的检测. 释放闲置超过5 分钟的 span 物理内存; 如果超过2 分钟没有垃圾回收，强制执行; 将长时间未处理的 netpoll 添加到全局队列; 向长时间运行的 G 任务发出抢占调度(超过10ms的 g，会进行 retake); 收回因 syscall 长时间阻塞的 P; scavenger: 只是由goroutine运行.用于执行heap的内存回收给os ​ 先于main函数执行，实现包级别的一些初始化操作 ​ 主要作用: 初始化不能采用初始化表达式初始化的变量; 程序运行前的注册 实现sync.Once功能 ​ 主要特点: init函数先于main函数自动执行，不能被其他函数调用； init函数没有输入参数、返回值； 每个包可以有多个init函数； 包的每个源文件也可以有多个init函数，这点比较特殊； 同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序 不同包的init函数按照包导入的依赖关系决定执行顺序 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:11","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"12.包的循环引用 为什么不允许循环引用 ​ 加快编译速度、规范框架设计，使项目结构更加清晰明了 解决办法: 1. mvc 结构,将包规划好 1. 新建公共接口包(父包), 将需要循环调用的函数或方法抽象为接口 1. 新建公共组合包(子包), 在组合包中组合调用 1. 全局存储需要相互依赖的函数, 通过关键字进行调用 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:12","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"13. SELECT select可以用来等待多个channel的可读可写，其中select中的case表达式必须都是channel的读写操作。 当存在default时，select执行的就是非阻塞收发，当不存在时，必须等待某一个channel可读或可写。 当多个channel都可读可写时，会随机选择一个分支。 如果有一个channel已关闭,则每次都执行到这个case; 如果只有一个case,则出现死循环. var c1, c2, c3 chan int var i1, i2 int select { case i1 = \u003c-c1: fmt.Printf(\"received \", i1, \" from c1\\n\") case c2 \u003c- i2: fmt.Printf(\"sent \", i2, \" to c2\\n\") case i3, ok := (\u003c-c3): // same as: i3, ok := \u003c-c3 if ok { fmt.Printf(\"received \", i3, \" from c3\\n\") } else { fmt.Printf(\"c3 is closed\\n\") } default: fmt.Printf(\"no communication\\n\") } x, ok := \u003c-ch,如果ch已经关闭,则ok为false,置ch为nil,则可以继续阻塞. ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:1:13","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"进阶原理 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:2:0","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"1. GMP模型和golang调度原理 ​ go中调度采用GMP算法，G表示一个goroutine，M表示machine一个真实的线程，P表示processor表示一个调度器 P由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。最大256 M的最大限制是10000个，但是内核很难支持这么多的线程数，所以这个限制可以忽略; 一般为CPU数 在P没有足够的M绑定运行时,则会创建一个M;每次创建一个M都会同步创建一个G0，它负责调度其它的G，每个M都有一个G0 每个 P有个局部队列，局部队列保存待执行的 goroutine(流程2)，当 M绑定的 P的的局部队列已经满了之后就 会把 goroutine 放到全局队列(流程2-1) 每个 P和一个 M绑定，M是真正的执行 P中 goroutine 的实体(流程3)，M 从绑定的 P中的局部队列获取 G来 执行 当 M绑定的 P的局部队列为空时，M会从全局队列获取到本地队列来执行 G(流程3.1)，当从全局队列中没有获取到可执行的 G时候，M会从其他 P 的局部队列中偷取 G来执行(流程3.2)，这种从其他 P偷的方式称为 work stealing 当 G因系统调用(syscall)阻塞时会阻塞 M，此时 P会和 M解绑即 hand off，并寻找新的 idle 的 M，若没有 idle 的 M就会新建一个 M(流程5.1)。 当 G因 channel 或者 network I/O 阻塞时，不会阻塞 M，M会寻找其他 runnable 的 G;当阻塞的 G恢复后会重新进入 runnable 进入 P队列等待执行(流程5.3) Work stealing ​ 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。 Hand off 本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。 利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。 抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个…在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。 如果没有P或怎样? 调度器把 G都分配到 M上，不同的 G在不同的 M并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源 是全局的，就会因为资源竞争照成很多性能损耗。 GMP 调度过程中存在哪些阻塞 I/O, select block on syscall channel 等待锁 runtime.Gosched() 抢占式调度 sysmon。这个函数会周期性地做epoll操作，同时它还会检测每个P是否运行了较长时间。如果检测到某个P状态处于syscall超过了一个sysmon的时间周期(20us)，并且还有其它可运行的任务，则切换P。 如果检测到某个P的状态为running，并且它已经运行了超过10ms，则会将P的当前的G的stackguard设置为StackPreempt。这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:2:1","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"2. 垃圾回收(GC) 垃圾回收常用方法 1. 引用计数(reference counting) ​ 如C++中的智能指针:shard_ptr; 优点：简单直接，回收速度快 缺点：需要额外的空间存放计数，无法处理循环引用的情况； 标记-清除(mark and sweep) ​ 标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。 优点：简单直接，速度快，适合可回收对象不多的场景 缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配； 分代搜集(generation) ​ java的jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基 本思想是，将堆划分为两个或多个称为代(generation)的空间。新创建的对象存放在称为新生代(young generation)中(一般来说，新生代的大小会比 老年代小很多)，随着垃圾回收的重复执行，生命周期较⻓的对 象会被提升(promotion)到老年代中(这里用到了一个分类的思路，这个是也是科学思考的一个基本思路)。 ​ 因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃 圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍 然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。 GOLANG的GC策略 ​ golang采用无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。 ​ 原因: golang的内存分配算法tcmalloc，基本上不会造成内存碎片，因此不需要使用对象整理。 golang对于存活时间短的对象直接分配在栈上面，go程死亡后栈会被回收，不需要gc的参与。 Go 以 STW 为界限，可以将 GC 划分为五个阶段：：栈扫描（开始时STW）;第一次标记（并发）;第二次标记（STW）;清除（并发）,归还 三色标记清扫法 white，grep，black;白色为需要清理的数据，黑色则不要清理。从根对象（全局变量、执行栈、寄存器(主要是指针)）开始循环，能访问到的标记为灰色，然后从灰色队列开始遍历，自身变成黑色。后续没有访问到的直接清理掉。 没有STW的三色标记法 条件1: 一个白色对象被黑色对象引用 (白色被挂在黑色下) 条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏 (灰色同时丢了该白色) 当以上两个条件同时满足时, 就会出现对象丢失现象! 屏障保护 为了减少STW的影响,又防止三色标记法出现对象丢失现象,出现屏障保护技术; 插入写屏障 ​ 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；一种相对保守的屏障技术，它会将有存活可能的对象都标记成灰色以满足强三色不变性. ​ 写屏障只会针对堆进行限制. 删除写屏障 ​ 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色； ​ 缺点是开始收集器时需要STW快照全局对象 混合写屏障 操作流程: ​ 1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)， ​ 2、GC期间，任何在栈上创建的新对象，均为黑色。 ​ 3、被删除的对象标记为灰色。(删除写屏障) ​ 4、被添加的对象标记为灰色。(插入写屏障) 该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色; 只需要针对堆内存扫描即可. GC触发机制 主动: 通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。 被动: 使用系统监控(sysmon)，当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。(步调算法可以通过gogc传参设置量控制gc的时间。也是go中唯一对外开放的配置gc的参数。默认值为100，也就是达到百分百后触发gc机制) GC细节 ##### 增量垃圾收集 ​ 增量地标记和清除垃圾，降低应用程序暂停的最长时间； ​ 传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW。增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间。 并发垃圾收集 ​ 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾； GC 如何调优 通过 go tool pprof 和 go tool trace 等工具 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的 拷贝。 需要时，增大 GOGC 的值，降低 GC 的运行频率。 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:2:2","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"3. 内存模型和内存管理 ","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:2:3","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":[],"content":"4. 并发和sync包","date":"2022-08-21","objectID":"/golang%E5%85%AB%E8%82%A1%E6%96%87/:2:4","tags":[],"title":"Golang八股文","uri":"/golang%E5%85%AB%E8%82%A1%E6%96%87/"}]