# Mysql八股文


<!--more-->

# Mysql数据库

## 逻辑架构

![截屏2022-08-29 上午10.21.50](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-29%20%E4%B8%8A%E5%8D%8810.21.50.png)

![截屏2022-08-29 上午10.22.13](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-29%20%E4%B8%8A%E5%8D%8810.22.13.png)

MySQL基架大致包括如下几大模块组件:

1. **MySQL向外提供的交互接口（Connectors）**: 

   ​		Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现与SQL的交互。

2. **管理服务组件和工具组件(Management Service & Utilities)**:

   ​        提供对MySQL的集成管理，如备份(Backup),恢复(Recovery),安全管理(Security)等

3. **连接池组件(Connection Pool)**: 

   ​		负责监听对客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。

4. **SQL接口组件(SQL Interface)**:

   ​		接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。

5. **查询分析器组件(Parser)**:

   ​		首先分析SQL命令语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理。

6. **优化器组件（Optimizer）**:

   ​		对SQL命令按照标准流程进行优化分析。

7. **缓存主件（Caches & Buffers）**:

   ​		缓存和缓冲组件

8. **MySQL存储引擎**:

   ​		关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的

9. 物理文件（File System）

   ​		实际存储`MySQL 数据库文件`和一些`日志文件`等的系统。

### MySQL 执行查询的过程

1. 客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配
2. 查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）
3. 语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。
4. 优化。是否使用索引，生成执行计划。
5. 交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。

### MySQL存储引擎

### InnoDB存储引擎

​		MySQL5.5版本之后，MySQL的默认内置存储引擎已经是InnoDB了. 主要特点:

1. 支持ACID事务。默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的。
2. 使用的锁粒度为行级锁，可以支持更高的并发；
3. 支持外键
4. 在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
5. 主键索引采用聚集索引(索引的数据域存储数据文件本身),二级索引的数据域存储主键的值;因此从二级索引查找数据，需要先通过二级索引找到主键值，再访问聚集索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。



#### InnoDB四大特性

##### 插入缓存（insert buffer)

​		索引数据存储在磁盘上，主键索引由于天然自增，无须磁盘的随机 I/O，只需不断追加即可。但普通索引大概率无序，默认情况下需要进行随机磁盘 I/O 操作，效率极差.为了解决**普通索引插入效率低下**的问题，InnoDB 存储引擎引入 Insert Buffer 的概念.

- 原理:   对于普通索引（非聚集索引）不是直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓存池中，如果在直接插入，否则先放入 Insert buffer 对象中，然后以一定频率和辅助索引页子节点进行合并操作，此时通常能将多个插入合并到一个操作中，提高插入性能

- 使用前提:  非聚集索引, 且索引不唯一

  ​		因为如果要保证索引唯一, 每次操作还得去判断当前索引值是否已存在，而判断又涉及到磁盘随机 I/O，从而发挥不出插入缓存的优势.

  

##### 二次写(double write)

​		InnoDB 索引页一般 16KB 大小，而操作系统写文件以 4KB 为单位，这就导致同一页需要分四块分别写入。此时就存在写完一块系统崩溃或者断电等特殊情况，此时就导致写入数据不完整的问题.

​		二次写就是为了解决该问题，double write 分为两部分，一部分 doublewrite buffer，其大小 2MB，另一部分是磁盘上共享表空间中连续的 128 个页，也是2MB

- 原理: 先将脏数据写入 doublewrite buffer，doublewrite buffer 每次 1MB 写入共享表空间的磁盘上，完成以上两步后调用 fsync 函数，将数据同步到各个表空间.

  ​		如果操作系统在将页写入磁盘的过程中崩溃，InnoDB 重启发现页数据损坏后，可以从共享表的 doublewrite 中找到副本，用于数据恢复.



##### 自适应哈希索引(ahi)

​		InnoDB 虽然主要使用 B+ 树作为索引结构，但在某些特殊场景下用到哈希索引。InnoDB 会监控对表上索引的查找，如果发现某个索引频繁被访问，则建立哈希索引。InnoDB 会自动根据访问的频率和模式来为某些页建立哈希索引.



##### 预读(read ahead)

​		请求一页的数据时，可以把后面几页的数据也一起返回，放到数据缓冲池中，这样如果下次刚好需要下一页的数据，就不再需要到磁盘读取

### MyISAM存储引擎

​	一个MyISAM表三个文件: 表结构.frm、索引.myi、数据 .myd,  

​		主要特点为：

1. 不支持事务
2. 不支持外键;如果强行增加外键,不会提示错误,只是外键不其作用;
3. 对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存；
4. 默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁； 
5. 采用非聚集索引,索引文件的数据存储指向数据文件的指针;
6. 存储表的总行数, count(*) 速度快



### MyISAM 和InnoDB区别

- InnoDB 支持事务、外键，MyISAM 都不支持
- InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。
- Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；
- InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。(select count(*))
- MyISAM 采用表级锁(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。所以InnoDB相对于MyISAM来说，更容易发生死锁，锁冲突的概率更大，而且上锁的开销也更大，因为需要为每一行加锁； InnoDB比MyISAM支持更高的并发
-  InnoDB数据与索引一起保存.ibd，MyISAM表结构.frm 索引.myi 数据.myd



### 引擎的选择(使用的场景)

- MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。
- Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。



## 索引

### 什么是索引

​		索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据 库表中数据。索引的实现通常使用 B树及其变种 B+树。

​		更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

- 优点
  1. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
  2.  通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
- 缺点
  1. 时间方面:创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也 要动态的维护，会降低增/改/删的执行效率;
  2. 空间方面:索引需要占物理空间。

#### 索引类型

1. 主键索引(聚集索引)

   数据列不允许重复，不允许为 NULL，一个表只能有一个主键。

2. 唯一索引

   数据列不允许重复，允许为 NULL值，一个表允许多个列创建唯一索引。

3. 普通索引

   基本的索引类型，没有唯一性的限制，允许为 NULL值。

4. 全文索引

   是目前搜索引擎使用的一种关键技术。

5. 联合索引

   

### 数据结构: B+树

![截屏2022-08-29 下午12.24.38](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-29%20%E4%B8%8B%E5%8D%8812.24.38.png)

​		在数据库中，B+Tree的高度一般都在2~4层。mysql的innoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

- B+树的非叶子节点不保存关键字记录的指针,只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加
- B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；

#### 为什么使用B+树,而不是B树

1. **B+数的层级更少**: 相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
2. **B+树查询速度更稳定**：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
3. **B+树天然具备排序功能**：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
4. **B+树全节点遍历更快**：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

> B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。



#### B+树和红黑树对比

1. B+数查询次数更少: 数高更低
2. 磁盘预读:  为了减少IO操作,往往不严格按需读取,而是预读.B+树叶子结点存储相临，读取会快一些。
3. 存储更多索引结点: B+树只在叶子结点储存数据，非叶子结点存索引，而一个结点就是磁盘一个内存页，内存页大小固定，那么相比B树这些可以存更多的索引结点，出度更大，树高矮，查询次数少，磁盘IO少。

### 使用索引一定会提高性能吗?

​		通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。

​		索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的 INSERT，DELETE， UPDATE 将为此多付出4，5 次的磁盘 I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询 反应时间变慢。



### 聚簇索引和非聚簇索引

#### 聚簇索引

​		将数据存储与索引放到了同一个文件中，找到索引也就找到了数据(即索引的叶子结点存储真正的数据)

1. 特点
   - 聚簇索引具有唯一性: 由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。
   - 表中行的物理顺序和索引中行的物理顺序是相同的: 在创建任何非聚簇索引之前创建聚簇索引，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；
   - 聚簇索引默认是主键; 如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。
   - MyISAM使用的是非聚簇索引
2. 优点

#### 非聚簇索引

将数据存储与索引分开，索引结构的叶子节点指向了数据的对应行，myisam通过 key_buffer 把索引先缓存到内存中，当需要访问数据时(通过索引访问数据)，在内存中直接搜索索引，然 后通过索引找到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢的原因。

![聚簇索引和非聚簇索引](https://raw.githubusercontent.com/NoobMidC/pics/main/1.png)

### 有索引以后查询的流程

1. 从索引里自上而下查询
2. 走到叶子节点查询到id
3. 根据id去聚簇索引中查找真正的数据，这个过程叫做`回表`
4. 如果你要的数据索引都有了不需要回表，就叫`索引覆盖`。

