# 操作系统八股文


<!--more-->

# 操作系统

## 进程管理

### 进程和线程

#### 进程组成

- 进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区(用于进程切换)，占有的资源清单等。
  - 程序段
- 数据段

#### 进程创建、终止

- 进程创建的方法
  1. 系统初始化（init）
  2. 正在运行的程序执行了创建进程的系统调用（比如 fork）
  3. 用户请求创建一个新进程
  4. 初始化一个批处理工作
- 进程终止的方法
  1. 正常退出：exit()
  2. 发生程序错误后退出(自愿的)
  3. 被其他进程杀死(如发送信号kill)

#### 进程和线程的区别

​		一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而 存在。

- 调度: 进程是资源管理的基本单位，线程是程序执行的基本单位
- 切换: 线程上下文切换比进程上下文切换要快得多
- 拥有资源:进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。
- 系统开销:创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O 设备等，OS所付出的 开销显著大于在创建(只有栈的开销)或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。

![123](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8B%E5%8D%885.44.57.png)

​			左侧为进程中每个线程共享的内容，右侧为线程单独的内容



#### 协程，进程，线程的区别

![截屏2022-08-27 下午3.59.42](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8B%E5%8D%883.59.42.png)



### 进程状态

​		进程一共有5 种状态，分别是创建、就绪、运行(执行)、终止、阻塞。

![截屏2022-08-27 上午10.58.52](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8A%E5%8D%8810.58.52.png)

- 运行状态就是进程正在 CPU上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。 
- 就绪状态就是说进程已处于准备运行的状态，即进程获得了除 CPU之外的一切所需资源，一旦得到 CPU即可 运行。
-  阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待 I/O 完成。即使 CPU空闲， 该进程也不能运行。

运行态**→**阻塞态:往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。

阻塞态**→**就绪态:则是等待的条件已满足，只需分配到处理器后就能运行。

运行态**→**就绪态:不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如 时间片用完，或有更高优先级的进程来抢占处理器等。

就绪态**→**运行态:系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。					

### 进程和线程的切换流程

- 进程切换:

  切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。

  切换内核栈和硬件上下文。

  

- 线程切换

​				线程切换时因为其共享所在进程的虚拟地址空间的, 所以不需要切换地址空间,只需要切换内核栈和上下文

### 为什么虚拟空间的切换特别耗时?

​		进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用 Cache 来缓存常用的地址映射，这样可以加速页表查找，这个 Cache 就是 TLB(translation Lookaside Buffer， TLB本质上就是一个 Cache，是用来加速页表查找的),即快表.	

​		显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后 TLB就失效了，Cache 失效导致命 中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢

### 进程通信方式

- 管道 (速度慢，容量有限;)

> 管道可以分为两类:匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信;命名管道FIFO以磁盘文件的方式存在，可以实现本机任意两个进程通信。

- 信号

> 常用信号: 
>
> 1. SIGHUP: 用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
> 2. SIGINT: 程序终止信号。程序运行过程中，按 Ctrl+C 键将产生该信号。
> 3. SIGQUIT:程序退出信号。程序运行过程中，按 Ctrl+\键将产生该信号
> 4. SIGBUS和 SIGSEGV:进程 访问非法地址。
> 5. **SIGKILL**:用户终止进程执行信号。shell 下执行 kill -9 发送该信号。

- 信号量: 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程 正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手 段。(不能传递复杂消息，只能用来同步;)
- 消息队列。 (容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题;)
- 共享内存:共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都 可以访问。共享内存是最快的 IPC 方式(能够很容易控制容量，速度快，但要保持同步)
- Socket: 不同机器间的进程间通信



### 进程间同步的方式

- 临界区

  ​	通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

  ​	优点: 保证在某一时刻只有一个线程能访问数据的简便办法

  ​	缺点: 虽然然临界区同步速度很快，但却只能用来同步
  本进程内的线程，而不可用来同步多个进程中的线程。

  ​	

  ​	冲突解决:

  1. 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入，如已有进程进入自己的临界区，则其它所 有试图进入临界区的进程必须等待;
  2. 进入临界区的进程要在有限时间内退出。
  3. 如果进程不能进入自己的临界区，则应让出 CPU，避免进程出现“忙等”现象。

  

- 互斥量

  ​	互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只
  有拥有互斥对象的线程才具有访问资源的权限。

  ​	优点: 使用互斥不仅仅能够在同一应用程序不同线程中实现资源的
  安全共享，而且可以在**不同进程**的线程之间实现对资源的安全共享。

  ​	缺点: 1. 消耗的资源较多 2. 只能针对一个资源进行同步访问,没办法计数

  

- 信号量

  ​      为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同 一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。

  ​       优点: 适用于对 Socket(套接字)程序中线程的同步。

  ​       缺点:  1. 必须有公共内存，不能用于分布式操作系统，这是它最大的弱点; 2. 对信号量的操作分散，而且难以控制，读写和维护都很困难

​	

### 线程同步方式

- 临界区:	当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的 资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操作 共享资源的目的

  

- 事件机制:    事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务

  

- 互斥量:     互斥对象和临 界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资 源，更有效率

  

- 信号量:     当需要一个计数器来限制可以使用某共享资源的线程数目时,可以使用信号量

> a.  互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使用，但创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用
> 量.
>
> b.  互斥量，信号量，事件都可以被跨越进程使用来进行同步数据操作。



### 死锁和死锁产生的条件

​		两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着 的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁.

- 四个必要条件
  1. 互斥条件:一个资源一次只能被一个进程使用
  2. 请求与保持条件:一个进程因请求资源而阻塞时，对已获得资源保持不放
  3. 非抢占: 进程获得的资源，在未完全使用完之前，不能强行抢占
  4. 循环等待条件:若干进程之间形成一种头尾相接的环形等待资源关系
- 死锁问题解决:
  1. 资源一次性分配，这样就不会再有请求了(破坏请求条件)。
  2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源(破坏占有并等待条件)。
  3. 可抢占资源:即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。
  4. 资源有序分配法:系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件



### 进程调度策略

- 先来先服务: 非抢占式的调度算法，按照请求的顺序进行调度。

  ​		有利于长作业，但不利于短作业，因为短作业 必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很⻓时间，造成了短作业等待时间过长。 另外，对 I/O 密集型进程也不利，因为这种进程每次进行 I/O 操作之后又得重新排队.

​				

- 短作业优先: 非抢占式的调度算法，按估计运行时间最短的顺序进行调度

  ​		长作业有可能会饿死，处于一直等 待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度

  

- 最短剩余时间优先: 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度

  ​		当一个新的作业到达时， 其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

  

- **时间片轮转**:   将所有就绪进程按 FCFS的原则排成一个队列，每次调度时，把 CPU时间分配给队首进程，该进程可 以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU时间分配给队 首的进程。

  ​	a. 时间片轮转算法的效率和时间片的大小有很大关系:因为进程切换都要保存进程的信息并且载入新进程的信 息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。

  ​	b. 优先级调度:为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

  

- 多级队列调度算法:  将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。



- 多级反馈队列调度算法: 为就绪队列赋予不同的优先级数，不同的时间片，按照优先级抢占CPU的调度算法;
  1. 优先权越高，队列的时间片越小.
  2. 首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程
  3. 同一个队列中的各个进程，按照 时间片轮转法调度 
  4. 在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业即抢占式调度CPU

### 孤儿进程和僵尸进程

- 孤儿进程: 父进程已退出，但子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程(1号进程)所收养，并由init进程对他们完成状态收集工作。

- 僵尸进程: 进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。

  1. 危害:僵尸进程会占用系统资源, 没有回收导致内存泄漏
  2. 避免:  手动杀死父进程,让子进程变成孤儿进程由init进程回收;  严格回收子进程

  

###  IO多路复用

​		IO多路复用是指内核一旦发现进程指定的一个或者多个 IO条件准备读取，它就通知该进程。

- 适用场景
  1. 当客户处理多个描述字时(一般是交互式输入和网络套接口)，必须使用 I/O 复用。 
  2. 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
  3. 如果一个 TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到 I/O 复用。
  4.  如果一个服务器即要处理 TCP，又要处理 UDP，一般要使用 I/O 复用。
  5.  如果一个服务器要处理多个服务或多个协议，一般要使用 I/O 复用。
  6. 与多进程和多线程技术相比，I/O 多路复用技术的最大优势是**系统开销小**，系统不必创建进程/线程，也不必 维护这些进程/线程，从而大大减小了系统的开销。



### 写时复制

- 如果进程从来就不需要修改资源，则不需要进行复制,每个进程只要保存一 个指向这个资源的指针就可以了。惰性算法的好处 就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。
- 在使用虚拟内存的情况下，写时复制(Copy-On-Write)是以页为基础进行的。所以，只要进程不 修改它全部的地址空间，那么就不必复制整个地址空间。在fork()调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。



###  中断

​		简单来说就是**CPU停下当前的工作任务，去处理其他事情，处理完后回来继续执行刚才的任务**，这一过程便是中断。

- 中断的处理过程**?**
  1. 保护现场:将当前执行程序的相关数据保存在寄存器中，然后入栈。
  2. 开中断:以便执行中断时能响应较高级别的中断请求。
  3. 中断处理
  4.  关中断:保证恢复现场时不被新中断打扰
  5.  恢复现场:从堆栈中按序取出程序数据，恢复中断前的执行状态。



### 优先级反转问题

​		由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高 优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。

​		解决:

- 优先级继承(priority inheritance) :是指将低优先级任务的优先级提升到等待它所占有的资 源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先 级将会自动被提升。
- 优先级天花板(priority ceilings):是指将申请某资源的任务的优先级提升到可能访问该资 源的所有任务中最高优先级任务的优先级

## 内存管理

### 1. 分页

​		把内存空间划分为大小相等且固定的块，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。访问分页系统中内存数据 需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址;第二 次就是根据第一次得到的物理地址访问内存取出数据)。

> ​	分片是由于分段的粒度太大,容易产生大量外部碎片. 而且对于某一个段进行内存置换代价也过大,因此进行段页式内存管理. 
>
> ​	每个页为4KB, 如果要规避分段,只需要跟linux一样将每个段的首地址设置为0,这样寻址则从内存开始出寻址,跟没分段一样.

![截屏2022-08-27 上午11.11.43](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8A%E5%8D%8811.11.43.png)



#### 多级页表

一个进程的页表可能很大, 一次性加载到内存中会浪费空间, 因此产生了多级页表, 一次只加载所需要的页表,用于节省内存空间.

![img](https://raw.githubusercontent.com/noobmid/pics/main/SouthEast.png)



#### 快表

快表（TLB）：提高变换速度→用高速缓冲存储器存放常用的页表项

MMU: 即内存管理单元，该硬件负责处理虚拟地址到物理地址的转化工作。快表也存储在MMU上。

### 2. 分段

​		分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保 护，动态链接等)。分段内存管理当中，地址是二维的，一维是段号，二维是段内地址;由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散 分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。

![截屏2022-08-27 下午12.08.34](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8B%E5%8D%8812.08.34.png)



### 3. 分段分页的区别

- 分页对程序员是透明的，但是分段需要程序员显式划分每个段。
-   分页的地址空间是一维地址空间，分段是二维的。
-   页的大小不可变，段的大小可以动态改变。
-   分页主要用于实现虚拟内存，从而获得更大的地址空间;分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。



### 4. 交换空间是什么

​		操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为页(page)。当内存资源不足时， Linux 把某些页的内容转移至硬盘上的一块空间上，以释放内存空间。硬盘上的那块空间叫做交换空间(swap space),而这一过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可用容量。

​	用途:

-   物理内存不足时一些不常用的页可以被交换出去，腾给系统。
-   程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。





### 5. 页面置换算法

​	在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

- **最佳算法**:所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 
- (先进先出)**FIFO**:
  1. 思路:置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。 
  2. 实现:按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。 
  3. 特点:实现简单;性能较差，调出的页面可能是经常访问的

- (最近最少使用)**LRU**: LRU将最近最久未使用的页面换出。

  1. 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU代价很高。

  2. 特点:可能达到最优的效果，维护这样的访问链表开销比较大

     

-  **时钟算法**:时钟算法使用环形链表将页面连接起来，再使用一个指针指向最开始的页面。当需要进行页面置换时，时钟指针开始转动寻找可置换页面，直到遇到访问位为0的页号为止。在这个过程中，将遇到的访问位为1的页全部置为0.时钟指针寻找到要被置换的页面后，将新页放于那个位置。



### 6. 缓冲区

​		缓冲区又称为缓存，它是**内存空间**的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来*缓冲输入或输出的数据*，这部分预留的空间就叫做缓冲区

![img](https://raw.githubusercontent.com/noobmid/pics/main/webp)

- 缓冲区溢出

  冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

  > 危害有以下两点:
  >   1. 程序崩溃，导致拒绝服务
  >   2. 跳转并且执行一段恶意代码造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入



### 7. 虚拟内存

​		在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种虚拟内存的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了缺页异常，操作系统才会将磁盘页面复制到内存中。

> 虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。
>
> 虚拟内存是一种对主存的抽象概念,其为每个进程提供了一个全物理内存的、一致的和私有的地址空间

#### 虚拟内存主要能力:

- 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要 在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
- 操作系统为每个进程提供了一个独立的页表(一致的地址空间)，也就是独立的虚拟地 址空间。多个虚拟页面可以映射到同一个物理页面上。从而简化了内存管理。
- 它保护了每个进程的地址空间不被其他进程破坏。

#### 为什么引入虚拟内存?

- **简化链接**:  独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据 实际存放在物理内存的何处
- **简化加载**: 加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页
- **简化共享**:  
  1. 一般来说, 每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，这样OS创建页表，将虚拟页映射到不连续的物理页面。
  2. 某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码， 或者C标准库函数。OS会把不同进程中适当的虚拟页面映射到相同的物理页面。
- **简化内存分配**:

#### 虚拟地址转换到物理地址的过程

​		虚拟地址由虚拟页号和页偏移两部分组成。通过虚拟地址的页面号，首先在快表中查询是否有该映射，查询成功，在页表中找到该页对应的物理地址。然后通过页物理地址+页偏移，得到真实的物理地址





### 8. 内存分配和回收

​	为了防止内存碎片，把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。

![截屏2022-08-27 下午5.59.24](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8B%E5%8D%885.59.24.png)

​	假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了则将页框块分为2个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误。页框块在释放时，会主动将两个连续的页框块合并为一个较大的页框块。



## 系统管理

### 1. 内核态和用户态切换

- **系统调用**:  	系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断.
- **异常**:    也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。
- 外部中断:     是通过两根信号线来通知处理器外设的状态变化，是硬中断。





### 2. 内核态和用户态的区别

- 处于内核态的进程可以访问系统的所有数据，并且cpu不会发生抢占。

- 处于用户态的进程只能受限得访问内存，并且cpu会被抢占。

- 操作系统从用户态跳转到内核态![截屏2022-08-27 下午5.21.00](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8B%E5%8D%885.21.00.png)



### 3. OS启动过程

![截屏2022-08-27 下午5.21.47](https://raw.githubusercontent.com/noobmid/pics/main/%E6%88%AA%E5%B1%8F2022-08-27%20%E4%B8%8B%E5%8D%885.21.47.png)



### 4. 系统调用

| 调用                                 | 说明                     |
| ------------------------------------ | ------------------------ |
| pid = fork()                         | 创建与父进程相同的子进程 |
| pid = waitpid(pid, &statloc,options) | 等待一个子进程终止       |
| s = execve(name,argv,environp)       | 替换一个进程的核心映像   |
| exit(status)                         | 终止进程执行并返回状态   |
|                                      |                          |

- fork()， 它创建一个原有进程的副本，包括所有的文件描述符、寄存器等内容。fork 调用会返回一个值，在子进程中该值为 0 ，并且在父进程中等于子进程的 进程标识符(Process IDentified,PID)。使用返回的 PID，就可以看出来哪个是父进程和子进程。
- waitpid：为了等待子进程完成，父进程需要执行 waitpid 系统调用，父进程会等待直至子进程终止（若有多个子进程的话，则直至任何一个子进程终止）。waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个比较老的子进程。




